#include<iostream>


/* Funkcje dla zadania z bloku 4 - Termin 0:
*  Jej zadaniem jest wyznaczyć położenie miejsca zerowego funkcji w zadanym zakresie.
*  Algorytm działa w założeniu, że we wskazanym zakresie funkcja ma tylko jedno
*  miejsce zerowe. Na granicach zakresu funkjca powinna przyjmować wartości
*  o przeciwnych znakach. Kolejne kroki podane są w ciele funkcji.
*/

double funkcja(double a, double b, double c, double d, double x)
{
    return a * x * x * x + b * x * x + c * x + d;
}
struct wejscie
{
    double xp;
    double xk;
    double a;
    double b;
    double c;
    double d;
    int n;
    double epsilon;
};
struct wyjscie
{
    double x0;
    double fx0;
    double roznica;
    bool powodzenie;
};

wyjscie miejsceZerowe(wejscie dane)
{
    /*UWAGA:  f(x) uzyskujemy przez wywołanie: funkcja(a,b,c,d,x) */
    /* 0. sprawdź czy xk > xp i f(xk) ma różny znak od f(xp) jesli
     * którykolwiek z tych warunków nie jest spełniony - zakończ funkcję
     * z sygnalizacją błędu (arg. powodzenie równy false).
     */

     /* Powtarzaj n razy: */
        /* Wyznacz parametry (wsp. kierunkowy i wyraz wolny) funkcji liniowej g(x)
         * przechodzącej przez punkty (xp,f(xp)) i (xk,f(xk)). */
         /* Wylicz miejsce zerowe x0 otrzymanej funkcji liniowej g(x). */
         /* Wylicz f(x0) i */
             /* zastąp xp wartością x0 jeśli f(x0) i f(xp) mają ten sam znak */
             /* w przeciwnym wypadku zastąp xk wartością x0. */
       /* zwróć ostatnie x0 (funkcja musi sygnalizować powodzenie równe true) */
    wyjscie wynik;
    wynik.powodzenie = false;
    if (dane.xk <= dane.xp || (funkcja(dane.a, dane.b, dane.c, dane.d, dane.xp) * funkcja(dane.a, dane.b, dane.c, dane.d, dane.xk) > 0))
    {
        return wynik;
    }
    double x0, fx0, fxp, fxk, gxp, gxk;
    double roznica = INFINITY;
    for (int i = 0; i < dane.n; i++)
    {
        fxp = funkcja(dane.a, dane.b, dane.c, dane.d, dane.xp);
        fxk = funkcja(dane.a, dane.b, dane.c, dane.d, dane.xk);
        gxp = dane.xp;
        gxk = (fxk - fx0) / (dane.xk - dane.xp);
        x0 = gxp - (fxp / gxk);
        fx0 = funkcja(dane.a, dane.b, dane.c, dane.d, x0);
        roznica = abs(x0 - dane.xp);
        if (fxp * fx0 > 0)
        {
            dane.xp = x0;
        }
        else
        {
            dane.xk = x0;
        }

        if (roznica < dane.epsilon)
        {
            break;
        }
        wynik.x0 = x0;
        wynik.fx0 = fx0;
        wynik.roznica = roznica;
        wynik.powodzenie = true;
    }

    return wynik;
}
void wypelnij(wejscie& dane)
{
    dane.xp = -2.0;
    dane.xk = 5.0;
    dane.a = 3.5;
    dane.b = 2.0;
    dane.c = 7.0;
    dane.d = -4.0;
    dane.n = 100;
    cout << "Podaj epsilon (mala liczba)";
    cin >> dane.epsilon;
}
void poka(wyjscie dane)
{
    if (dane.powodzenie)
    {
        cout << "Wartosc tego w miejscu " << dane.x0 << " wynois" << dane.fx0 << endl;
        cout << "Roznica miedzy oszacowaniami wynosi " << dane.roznica << endl;
    }
    else
    {
        cout << "To co se wymysliles nie ma miejsc zerowych (BRAWO!)" << endl;
    }

}
/* Polecenie 2: Zmodyfikuj kod programu tak, aby agorytm kończył się jeśli różnica pomiędzy
 * dwoma kolejnymi oszacowaniami wyniku (x0) jest mniejsza od zadenego eps.
 * Zmodyfikuj tak interfejs funkcji, aby można było zadać eps, oraz zwrócić wartość f(x0) i różnicę
 * w oszacowaniach (wartość sparwdzaną w nowym kryterium zbieżności).
 */

 /* Polecenie 3: Zmodyfikuj tak interfejs funkcji, aby wszytskie dane wejściowe przekazywać
  * za pomocą struktury, oraz wszystkie wyniki odbierać w postaci struktury. Napisz funkcje
  * do wypełniania struktury wejściwem treścią i do wyświetlania struktury wyjściowej na ekranie.
  */

using namespace std;

int main()
{
    /* main dla zadania z bloku 4*/
    wejscie daneWejsciowe;
    wypelnij(daneWejsciowe);
    wyjscie daneWyjsciowe = miejsceZerowe(daneWejsciowe);
    poka(daneWyjsciowe);

}
